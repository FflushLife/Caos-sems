По мотивам https://github.com/victor-yacovlev/mipt-diht-caos/tree/master/practice/asm/nostdlib_baremetal

### Дополнение:
На данный момент использование `int 0x80` считается дурным тоном (в основном,
дело в накладных расходах). На смену этому прерыванию пришли специальные
команды syscall и sysenter (x64, x32 соответственно).

Номера системных вызовов перечислены в файлах
`/usr/include/asm/unistd_32.h` или `/usr/include/asm/unistd_64.h` в зависимости
от Вашей архитектуры. Эти файлы можно подключить, как в Си программе
и пользоваться удобными литералами вместо констант. Например, 
`__NR_write` вместо `1`.

### Немного о самих системных вызовах:
Поговорим в терминах упрощенной модели. После старта операционной системы
из загрузчика (например, grub или Windows Boot Manager), в память (RAM)
загружается скомпилированное ядро, которое начинает полную инициализацию
системы. После этого оно остаетсяв системе и предназначено для работы с
процессами, файловой системой, сетью и со всем остальным, что выбивается
из рамок памяти процесса. Но работа ядра не видна для пользователя.\

Поэтому, чтобы заставить ядро выполнить какую-либо задачу, существуют
системные вызовы, которые изначально вызывались с помощью прерываний - 
упрощенно говоря, сигналов процессору. В нашем случае нужен сигнал о том,
что надо поменять контекст исполнения с пользовательского на ядерный
(как раз тот самый `0x80`). Для этого сначала нужно положить все аргументы
для ядерной функции в регистры в нужном порядке (вторая таблица в 
https://man7.org/linux/man-pages/man2/syscall.2.html). Затем послать сигнал
(int 0x80, syscall или sysenter - выбирайте с умом). В примерах можно найти
демонстрацию для системного вызова write, который выведет в консоль текст.
